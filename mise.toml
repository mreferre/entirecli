[tools]
# Please also keep the version aligned in the go.mod file
go = { version = '1.25.6', postinstall = "go install github.com/go-delve/delve/cmd/dlv@latest" }
golangci-lint = '2.8.0'
shellcheck = 'latest'

[tasks.fmt]
description = "Run gofmt"
run = "gofmt -s -w ."

[tasks.test]
description = "Run tests"
run = "go test ./..."

[tasks."test:integration"]
description = "Run integration tests"
run = "go test -tags=integration ./cmd/entire/cli/integration_test/..."

[tasks."test:ci"]
description = "Run all tests (unit + integration) with race detection"
run = "go test -tags=integration -race ./..."

[tasks.build]
description = "Build the CLI"
run = """
VERSION=$(git describe --tags --always --dirty 2>/dev/null || echo "dev")
COMMIT=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
go build -ldflags "-X github.com/entireio/cli/cmd/entire/cli/buildinfo.Version=${VERSION} -X github.com/entireio/cli/cmd/entire/cli/buildinfo.Commit=${COMMIT}" -o entire ./cmd/entire
"""

[tasks."build:all"]
description = "Build for all platforms using goreleaser"
run = "goreleaser build --snapshot --clean"

[tasks."completions"]
description = "generate entire shell completions"
quiet = true
run = """
rm -rf completions
mkdir completions
for sh in bash zsh fish; do
    go run ./cmd/entire/main.go completion "$sh" >"completions/entire.$sh"
done
"""

[tasks.dup]
description = "Check for code duplication (threshold 50, with summary)"
run = """
#!/usr/bin/env bash
set -euo pipefail

# Create temp files with proper extensions (works on both Linux and macOS)
tmpdir=$(mktemp -d)
config="$tmpdir/config.yaml"
json_out="$tmpdir/output.json"

cat > "$config" << 'YAML'
version: "2"
linters:
  default: none
  enable: [dupl]
  settings:
    dupl:
      threshold: 50
YAML

# Run with JSON output for summary, text output for details
golangci-lint run -c "$config" --new=false --max-issues-per-linter=0 --max-same-issues=0 \
  --output.json.path="$json_out" --output.text.path=/dev/stderr ./... 2>&1 || true

# Print summary grouped by file
echo ""
echo "=== Duplication Summary (by file) ==="
if command -v jq &>/dev/null && [ -s "$json_out" ]; then
  jq -r '.Issues // [] | group_by(.Pos.Filename) | map({file: (.[0].Pos.Filename | split("/") | .[-1]), count: length}) | sort_by(-.count) | .[] | "  " + (.count|tostring) + " " + .file' "$json_out" 2>/dev/null || echo "  (no issues)"
else
  echo "  (install jq for summary)"
fi

rm -rf "$tmpdir"
"""

[tasks."dup:staged"]
description = "Check duplication in staged files only (threshold 75, same as CI)"
run = """
#!/usr/bin/env bash
set -euo pipefail

# Get staged Go files, preserving paths with spaces using null delimiters throughout
if ! git diff --cached --name-only -z --diff-filter=ACM | grep -z '\\.go$' | grep -zq .; then
  echo "No staged Go files to check"
  exit 0
fi
echo "Checking staged files for duplication..."
git diff --cached --name-only -z --diff-filter=ACM | grep -z '\\.go$' | xargs -0 golangci-lint run --enable-only dupl --new=false --max-issues-per-linter=0 --max-same-issues=0
"""

[tasks.bench]
description = "Run all benchmarks"
run = "go test -bench=. -benchmem -run='^$' -timeout=10m ./..."

[tasks."bench:cpu"]
description = "Run benchmarks with CPU profile (single package)"
run = """
#!/usr/bin/env bash
set -euo pipefail
PKG="${BENCH_PKG:-./cmd/entire/cli/benchutil/}"
echo "Profiling package: $PKG (override with BENCH_PKG=./path/to/pkg)"
go test -bench=. -benchmem -run='^$' -cpuprofile=cpu.prof -timeout=10m "$PKG"
echo "Profile saved to cpu.prof. View with: go tool pprof -http=:8080 cpu.prof"
"""

[tasks."bench:mem"]
description = "Run benchmarks with memory profile (single package)"
run = """
#!/usr/bin/env bash
set -euo pipefail
PKG="${BENCH_PKG:-./cmd/entire/cli/benchutil/}"
echo "Profiling package: $PKG (override with BENCH_PKG=./path/to/pkg)"
go test -bench=. -benchmem -run='^$' -memprofile=mem.prof -timeout=10m "$PKG"
echo "Profile saved to mem.prof. View with: go tool pprof -http=:8080 mem.prof"
"""

[tasks."bench:compare"]
description = "Compare benchmarks between current branch and main"
run = """
#!/usr/bin/env bash
set -euo pipefail

# Install benchstat if not available
if ! command -v benchstat &>/dev/null; then
  echo "Installing benchstat..."
  go install golang.org/x/perf/cmd/benchstat@latest
fi

BENCH_PATTERN="${BENCH_PATTERN:-.}"
BENCH_COUNT="${BENCH_COUNT:-6}"
BENCH_TIMEOUT="${BENCH_TIMEOUT:-10m}"
BASE_REF="${BASE_REF:-main}"

current_branch=$(git rev-parse --abbrev-ref HEAD)
if [ "$current_branch" = "$BASE_REF" ]; then
  echo "Already on $BASE_REF â€” nothing to compare. Run from a feature branch."
  exit 1
fi

tmpdir=$(mktemp -d)
new_out="$tmpdir/new.txt"
old_out="$tmpdir/old.txt"

cleanup() {
  local exit_code=$?
  # Restore original branch if we're not on it
  if [ "$(git rev-parse --abbrev-ref HEAD)" != "$current_branch" ]; then
    git checkout "$current_branch" --quiet 2>/dev/null || true
  fi
  # Pop stash if we pushed one
  if [ "$has_changes" = true ]; then
    git stash pop --quiet 2>/dev/null || true
  fi
  rm -rf "$tmpdir"
  exit $exit_code
}
trap cleanup EXIT

echo "=== Benchmarking current branch ($current_branch) ==="
go test -bench="$BENCH_PATTERN" -benchmem -run='^$' -count="$BENCH_COUNT" -timeout="$BENCH_TIMEOUT" ./... > "$new_out" 2>&1 || true

# Check for uncommitted changes
has_changes=false
if ! git diff --quiet || ! git diff --cached --quiet; then
  has_changes=true
  echo "Stashing uncommitted changes..."
  git stash push -m "bench:compare auto-stash"
fi

echo ""
echo "=== Benchmarking base ($BASE_REF) ==="
git checkout "$BASE_REF" --quiet
go test -bench="$BENCH_PATTERN" -benchmem -run='^$' -count="$BENCH_COUNT" -timeout="$BENCH_TIMEOUT" ./... > "$old_out" 2>&1 || true

echo ""
echo "=== Switching back to $current_branch ==="
git checkout "$current_branch" --quiet
if [ "$has_changes" = true ]; then
  git stash pop --quiet
fi

echo ""
echo "=== Results (base=$BASE_REF vs current=$current_branch) ==="
echo ""
benchstat "$old_out" "$new_out"
"""

[tasks."test:e2e"]
description = "Run E2E tests with real agent calls (requires claude CLI)"
# -count=1 disables test caching since E2E tests call real external agents
run = "go test -tags=e2e -count=1 -timeout=30m -v ./cmd/entire/cli/e2e_test/..."

[tasks."test:e2e:claude"]
description = "Run E2E tests with Claude Code (haiku model)"
run = "E2E_AGENT=claude-code go test -tags=e2e -count=1 -timeout=30m -v ./cmd/entire/cli/e2e_test/..."

[tasks."test:e2e:gemini"]
description = "Run E2E tests with Gemini CLI (sequential to avoid rate limits)"
run = "E2E_AGENT=gemini go test -tags=e2e -count=1 -parallel 1 -timeout=30m -v ./cmd/entire/cli/e2e_test/..."
