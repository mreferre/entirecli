package opencode

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/entireio/cli/cmd/entire/cli/agent"
	"github.com/entireio/cli/cmd/entire/cli/paths"
)

// Compile-time interface assertion
var _ agent.HookSupport = (*OpenCodeAgent)(nil)

const (
	// pluginFileName is the name of the plugin file written to .opencode/plugins/
	pluginFileName = "entire.ts"

	// pluginDirName is the directory under .opencode/ where plugins live
	pluginDirName = "plugins"

	// entireMarker is a string present in the plugin file to identify it as Entire's
	entireMarker = "Auto-generated by `entire enable --agent opencode`"
)

// getPluginPath returns the absolute path to the plugin file.
func getPluginPath() (string, error) {
	repoRoot, err := paths.WorktreeRoot()
	if err != nil {
		// Fallback to CWD if not in a git repo (e.g., during tests)
		//nolint:forbidigo // Intentional fallback when WorktreeRoot() fails (tests run outside git repos)
		repoRoot, err = os.Getwd()
		if err != nil {
			return "", fmt.Errorf("failed to get current directory: %w", err)
		}
	}
	return filepath.Join(repoRoot, ".opencode", pluginDirName, pluginFileName), nil
}

// InstallHooks writes the Entire plugin file to .opencode/plugins/entire.ts.
// Returns 1 if the plugin was installed, 0 if already present (idempotent).
func (a *OpenCodeAgent) InstallHooks(localDev bool, force bool) (int, error) {
	pluginPath, err := getPluginPath()
	if err != nil {
		return 0, err
	}

	// Check if already installed (idempotent) unless force
	if !force {
		if _, err := os.Stat(pluginPath); err == nil {
			data, readErr := os.ReadFile(pluginPath) //nolint:gosec // Path constructed from repo root
			if readErr == nil && strings.Contains(string(data), entireMarker) {
				return 0, nil // Already installed
			}
		}
	}

	// Build the command prefix
	var cmdPrefix string
	if localDev {
		cmdPrefix = "go run ${OPENCODE_PROJECT_DIR}/cmd/entire/main.go"
	} else {
		cmdPrefix = "entire"
	}

	// Generate plugin content from template
	content := strings.ReplaceAll(pluginTemplate, entireCmdPlaceholder, cmdPrefix)

	// Ensure directory exists
	pluginDir := filepath.Dir(pluginPath)
	//nolint:gosec // G301: Plugin directory needs standard permissions
	if err := os.MkdirAll(pluginDir, 0o755); err != nil {
		return 0, fmt.Errorf("failed to create plugin directory: %w", err)
	}

	// Write plugin file
	//nolint:gosec // G306: Plugin file needs standard permissions for OpenCode to read
	if err := os.WriteFile(pluginPath, []byte(content), 0o644); err != nil {
		return 0, fmt.Errorf("failed to write plugin file: %w", err)
	}

	return 1, nil
}

// UninstallHooks removes the Entire plugin file.
func (a *OpenCodeAgent) UninstallHooks() error {
	pluginPath, err := getPluginPath()
	if err != nil {
		return err
	}

	if err := os.Remove(pluginPath); err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("failed to remove plugin file: %w", err)
	}

	return nil
}

// AreHooksInstalled checks if the Entire plugin file exists and contains the marker.
func (a *OpenCodeAgent) AreHooksInstalled() bool {
	pluginPath, err := getPluginPath()
	if err != nil {
		return false
	}

	data, err := os.ReadFile(pluginPath) //nolint:gosec // Path constructed from repo root
	if err != nil {
		return false
	}

	return strings.Contains(string(data), entireMarker)
}

// GetSupportedHooks returns the normalized lifecycle events this agent supports.
// OpenCode's native hooks map to standard agent lifecycle events:
//   - session-start → HookSessionStart
//   - session-end   → HookSessionEnd
//   - turn-start    → HookUserPromptSubmit (user prompt triggers a turn)
//   - turn-end      → HookStop (agent response complete)
//
// Note: HookNames() returns 5 hooks (including "compaction"), but GetSupportedHooks()
// returns only 4. The "compaction" hook is OpenCode-specific with no standard HookType
// mapping — it is handled via ParseHookEvent but not advertised as a standard lifecycle event.
func (a *OpenCodeAgent) GetSupportedHooks() []agent.HookType {
	return []agent.HookType{
		agent.HookSessionStart,
		agent.HookSessionEnd,
		agent.HookUserPromptSubmit,
		agent.HookStop,
	}
}
