// Entire CLI plugin for OpenCode
// Auto-generated by `entire enable --agent opencode`
// Do not edit manually — changes will be overwritten on next install.
// Requires Bun runtime (used by OpenCode's plugin system for loading ESM plugins).
import type { Plugin } from "@opencode-ai/plugin"

export const EntirePlugin: Plugin = async ({ $, directory }) => {
  const ENTIRE_CMD = "__ENTIRE_CMD__"
  // Track seen user messages to fire turn-start only once per message
  const seenUserMessages = new Set<string>()
  // Track current session ID for message events (which don't include sessionID)
  let currentSessionID: string | null = null
  // In-memory stores for message metadata
  const messageStore = new Map<string, any>()
  const partStore = new Map<string, any[]>()

  /**
   * Pipe JSON payload to an entire hooks command.
   * Errors are logged but never thrown — plugin failures must not crash OpenCode.
   */
  async function callHook(hookName: string, payload: Record<string, unknown>) {
    try {
      const json = JSON.stringify(payload)
      await $`echo ${json} | ${ENTIRE_CMD} hooks opencode ${hookName}`.quiet().nothrow()
    } catch {
      // Silently ignore — plugin failures must not crash OpenCode
    }
  }

  return {
    event: async ({ event }) => {
      switch (event.type) {
        case "session.created": {
          const session = (event as any).properties?.info
          if (!session?.id) break
          currentSessionID = session.id
          await callHook("session-start", {
            session_id: session.id,
          })
          break
        }

        case "message.updated": {
          const msg = (event as any).properties?.info
          if (!msg) break
          // Store message metadata (role, time, tokens, etc.)
          messageStore.set(msg.id, msg)
          break
        }

        case "message.part.updated": {
          const part = (event as any).properties?.part
          if (!part?.messageID) break

          // Accumulate parts per message
          const existing = partStore.get(part.messageID) ?? []
          const idx = existing.findIndex((p: any) => p.id === part.id)
          if (idx >= 0) {
            existing[idx] = part
          } else {
            existing.push(part)
          }
          partStore.set(part.messageID, existing)

          // Fire turn-start on the first text part of a new user message
          const msg = messageStore.get(part.messageID)
          if (msg?.role === "user" && part.type === "text" && !seenUserMessages.has(msg.id)) {
            seenUserMessages.add(msg.id)
            const sessionID = msg.sessionID ?? currentSessionID
            if (sessionID) {
              await callHook("turn-start", {
                session_id: sessionID,
                prompt: part.text ?? "",
              })
            }
          }
          break
        }

        case "session.idle": {
          const sessionID = (event as any).properties?.sessionID
          if (!sessionID) break
          // Go hook handler will call `opencode export` to get the transcript
          await callHook("turn-end", {
            session_id: sessionID,
          })
          break
        }

        case "session.compacted": {
          const sessionID = (event as any).properties?.sessionID
          if (!sessionID) break
          await callHook("compaction", {
            session_id: sessionID,
          })
          break
        }

        case "session.deleted": {
          const session = (event as any).properties?.info
          if (!session?.id) break
          seenUserMessages.clear()
          messageStore.clear()
          partStore.clear()
          currentSessionID = null
          await callHook("session-end", {
            session_id: session.id,
          })
          break
        }
      }
    },
  }
}
