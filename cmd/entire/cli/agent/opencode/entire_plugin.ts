// Entire CLI plugin for OpenCode
// Auto-generated by `entire enable --agent opencode`
// Do not edit manually — changes will be overwritten on next install.
// Requires Bun runtime (used by OpenCode's plugin system for loading ESM plugins).
import type { Plugin } from "@opencode-ai/plugin"

export const EntirePlugin: Plugin = async ({ client, directory, $ }) => {
  const ENTIRE_CMD = "__ENTIRE_CMD__"
  const transcriptDir = `${directory}/.opencode/sessions/entire`
  const seenUserMessages = new Set<string>()

  // In-memory stores — used to write transcripts without relying on the SDK API,
  // which may be unavailable during shutdown.
  // messageStore: keyed by message ID, stores message metadata (role, time, tokens, etc.)
  const messageStore = new Map<string, any>()
  // partStore: keyed by message ID, stores accumulated parts from message.part.updated events
  const partStore = new Map<string, any[]>()
  let currentSessionID: string | null = null

  // Ensure transcript directory exists
  await $`mkdir -p ${transcriptDir}`.quiet().nothrow()

  /**
   * Pipe JSON payload to an entire hooks command.
   * Errors are logged but never thrown — plugin failures must not crash OpenCode.
   */
  async function callHook(hookName: string, payload: Record<string, unknown>) {
    try {
      const json = JSON.stringify(payload)
      await $`echo ${json} | ${ENTIRE_CMD} hooks opencode ${hookName}`.quiet().nothrow()
    } catch {
      // Silently ignore — plugin failures must not crash OpenCode
    }
  }

  /** Extract text content from a list of parts. */
  function textFromParts(parts: any[]): string {
    return parts
      .filter((p: any) => p.type === "text")
      .map((p: any) => p.text ?? "")
      .join("\n")
  }

  /** Format a message for the transcript using its accumulated parts. */
  function formatMessageFromStore(msg: any) {
    const parts = partStore.get(msg.id) ?? []
    return {
      id: msg.id,
      role: msg.role,
      content: textFromParts(parts),
      time: msg.time,
      ...(msg.role === "assistant" ? {
        tokens: msg.tokens,
        cost: msg.cost,
        parts: parts.map((p: any) => ({
          type: p.type,
          ...(p.type === "text" ? { text: p.text } : {}),
          ...(p.type === "tool" ? { tool: p.tool, callID: p.callID, state: p.state } : {}),
        })),
      } : {}),
    }
  }

  /** Format a message from an API response (which includes parts inline). */
  function formatMessageFromAPI(info: any, parts: any[]) {
    return {
      id: info.id,
      role: info.role,
      content: textFromParts(parts),
      time: info.time,
      ...(info.role === "assistant" ? {
        tokens: info.tokens,
        cost: info.cost,
        parts: parts.map((p: any) => ({
          type: p.type,
          ...(p.type === "text" ? { text: p.text } : {}),
          ...(p.type === "tool" ? { tool: p.tool, callID: p.callID, state: p.state } : {}),
        })),
      } : {}),
    }
  }

  /**
   * Write transcript from in-memory stores (messageStore + partStore).
   * This does NOT call the SDK API, so it works even during shutdown.
   */
  async function writeTranscriptFromMemory(sessionID: string): Promise<string> {
    const transcriptPath = `${transcriptDir}/${sessionID}.json`
    try {
      const messages = Array.from(messageStore.values())
        .sort((a, b) => (a.time?.created ?? 0) - (b.time?.created ?? 0))

      const transcript = {
        session_id: sessionID,
        messages: messages.map(formatMessageFromStore),
      }
      await Bun.write(transcriptPath, JSON.stringify(transcript))
    } catch {
      // Silently ignore write failures
    }
    return transcriptPath
  }

  /**
   * Try to fetch messages via the SDK API (returns messages with parts inline)
   * and write transcript. Falls back to in-memory stores if the API is unavailable.
   */
  async function writeTranscriptWithFallback(sessionID: string): Promise<string> {
    const transcriptPath = `${transcriptDir}/${sessionID}.json`
    try {
      const response = await client.session.message.list({ path: { id: sessionID } })
      // API returns Array<{ info: Message, parts: Array<Part> }>
      const items = response.data ?? []

      const transcript = {
        session_id: sessionID,
        messages: items.map((item: any) => formatMessageFromAPI(item.info, item.parts ?? [])),
      }
      await Bun.write(transcriptPath, JSON.stringify(transcript))
      return transcriptPath
    } catch {
      // API unavailable (likely shutting down) — fall back to in-memory stores
      return writeTranscriptFromMemory(sessionID)
    }
  }

  return {
    event: async ({ event }) => {
      switch (event.type) {
        case "session.created": {
          const session = (event as any).properties?.info
          if (!session?.id) break
          currentSessionID = session.id
          await callHook("session-start", {
            session_id: session.id,
            transcript_path: `${transcriptDir}/${session.id}.json`,
          })
          break
        }

        case "message.updated": {
          const msg = (event as any).properties?.info
          if (!msg) break
          // Store message metadata (role, time, tokens, etc.)
          // Content is NOT on the message — it arrives via message.part.updated events.
          messageStore.set(msg.id, msg)
          break
        }

        case "message.part.updated": {
          const part = (event as any).properties?.part
          if (!part?.messageID) break

          // Accumulate parts per message
          const existing = partStore.get(part.messageID) ?? []
          // Replace existing part with same id, or append new one
          const idx = existing.findIndex((p: any) => p.id === part.id)
          if (idx >= 0) {
            existing[idx] = part
          } else {
            existing.push(part)
          }
          partStore.set(part.messageID, existing)

          // Fire turn-start on the first text part of a new user message
          const msg = messageStore.get(part.messageID)
          if (msg?.role === "user" && part.type === "text" && !seenUserMessages.has(msg.id)) {
            seenUserMessages.add(msg.id)
            const sessionID = msg.sessionID ?? currentSessionID
            if (sessionID) {
              await callHook("turn-start", {
                session_id: sessionID,
                transcript_path: `${transcriptDir}/${sessionID}.json`,
                prompt: part.text ?? "",
              })
            }
          }
          break
        }

        case "session.idle": {
          const sessionID = (event as any).properties?.sessionID
          if (!sessionID) break
          const transcriptPath = await writeTranscriptWithFallback(sessionID)
          await callHook("turn-end", {
            session_id: sessionID,
            transcript_path: transcriptPath,
          })
          break
        }

        case "session.compacted": {
          const sessionID = (event as any).properties?.sessionID
          if (!sessionID) break
          await callHook("compaction", {
            session_id: sessionID,
            transcript_path: `${transcriptDir}/${sessionID}.json`,
          })
          break
        }

        case "session.deleted": {
          const session = (event as any).properties?.info
          if (!session?.id) break
          // Write final transcript before signaling session end
          if (messageStore.size > 0) {
            await writeTranscriptFromMemory(session.id)
          }
          seenUserMessages.clear()
          messageStore.clear()
          partStore.clear()
          currentSessionID = null
          await callHook("session-end", {
            session_id: session.id,
            transcript_path: `${transcriptDir}/${session.id}.json`,
          })
          break
        }
      }
    },
  }
}
